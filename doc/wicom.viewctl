The creation of a new module wviewctl was motivated due to the
inexistence of interface between the plantmgr, shapemgr and
the wview in use.

Shapes are added using the shapemgr, these shapes can be
associated to plants and to layers. Plants are managed through
the plantmgr and each plant has an unique ID. Layers cannot
be dynamically added or removed, they belong to a static list.

wview receives attention whenever a new frame must be draw
then it needs the list of shapes or plants to draw, but these
two data types must be processed and linked (if a map is
not visible, its shapes shouldn't be drawn). This aditional
processing motivated the creation of wviewctl.

The user might also interact with the window of wview and
thats when the input callbacks are called (for mouse and
keyboard). So where should these callbacks be located in
the code? the code that needs to process user input from
the window is located in different parts of wicom, so I
tought this wviewctl interface can also fix that by providing
a way of multiplexing input callbacks between whoever
registered in wviewctl for the input callback.

So the client code can ask wviewctl to register input
callbacks and whenever wviewctl is called due to user input
it will call all registered callbacks of the client code.

wview should not know anything about shapes, layers or
plants, it just draws primitives (lines, polygons, ...).
Although, in the beginning shapes from the shapemgr should
be very similar to the primitive shapes provided by wview
in the future wview might have custom shapes made of various
wview shapes (eg. label = text + background rectangle).

WVIEWCTL INTERNALS

This module might need to use multithreading and synchronization
objects since all calls to the module are asynchronous in a
way that they return always. They should do the action and return
there is no loop function for wviewctl as there is in wview.
This can raise issues with the multithreading support of wview
interfaces. For that reason one thing should be assured, all
calls made to wview interface are made using the same thread.

When this module initializes, it creates a working thread.
This thread will communicate with the wview interface, initialize,
create the window, etc.

The client then can call wviewctl functions without disturbing
wview processing (like register callbacks to be included in
the multiplexing, etc.).

It is required then that the shapemgr and the plantmgr support
multithreading, so they should use synchronization objects
in the list of shapes and list of plants. The same applies to
wviewctl in the case of callback lists.

